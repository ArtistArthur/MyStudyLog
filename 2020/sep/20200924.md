# ljh
## 组合数
1.使用杨辉三角求解

C(n,m) = C(n-1,m) + C(n-1,m-1)

2. 组合数取余

使用逆元

lucas定理，今天没写，明天写一下练练手。

逆元的求解方法还需要再看看，很不熟悉。
扩展lucas定理后面有时间也可以看看。等忙完秋招最好写一篇关于组合数的博客。（笔试遇到过组合数求余）


## 并查集
主要是查，并，以及查的时候的路径压缩，理解了就很简单。

## 图
复习了下图的存储方式，用得比较多有邻接矩阵、邻接表、边集数组。

最小生成树的两种算法，Prim和kruskal算法，本质都是贪心。

最短路径求解算法，floyd、dijskra,Bellman-Ford算法，A*算法。一下子看得太多，有点乱，明天再看看，尽量整理清楚。

# lxy  
做了几道C++语法题
*** 
* int *p1 = new int[10]; 
* int *p2 = new int[10] ( ) ;
* p1申请的空间里的值是随机值，p2申请的空间里的值已经初始化
* 我本来以为就算有初始化括号，没有显式写0，内置类型也不会初始化，但是实际上会初始化为0   
*** 
~~~c
enum string{    
    x1,    
    x2,    
    x3=10,    
    x4,    
    x5,    
} x;
~~~   
函数外部访问x等于什么？   
这个考枚举类型初始化，以前没想过，去看了枚举  
* 枚举变量是全局变量的情况下，枚举值的缺省值是0，不是枚举的第一个值。 其他情况，其值是不定的，而且不限定于所列出的枚举值
* 枚举类型可以当作形参 void function(string x),并且可以重载
~~~c
enum Tokens{yellow=1, red};
void function(Tokens);
void function(int);
Tokens color=yellow;
function(color);//match void function(Tokens)
function(yellow);//match void function(Tokens)
function(1);//match void function(int)
~~~
* 枚举类型只能通过枚举对象或者枚举成员赋值，而不能通过整型赋值
* 但枚举可以隐式转换成整型赋值给整型


*** 
在Java中，以下关于方法重载和方法重写描述正确的是？  
  
方法重载和方法的重写实现的功能相同  错
方法重载出现在父子关系中，方法重写是在同一类中   错
方法重载的返回值类型必须一致，参数项必须不同  错
方法重写的返回值类型必须相同或相容。（或是其子类） 对  
同一作用域内的几个函数名字相同，但形参不同，叫做重载函数（overloaded），对返回类型没有要求； 
方法重载（overload）：   
1.必须是同一个类  
2方法名（也可以叫函数）一样  
3参数类型不一样或参数数量不一样  

重写（override）是子类对父类方法重写）    
方法的重写（override）两同两小一大原则：
方法名相同，参数类型相同  
子类返回类型小于等于父类方法返回类型，  
子类抛出异常小于等于父类方法抛出异常，  
子类访问权限大于等于父类方法访问权限。  


